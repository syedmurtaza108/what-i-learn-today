
# What I learn today
Contains my daily learning that I want to share with youüòÉ

# Flutter code compilation
**Develop**

(1) JIT + VM (**Mobile & Desktop**)
 - JIT compiler converts program source code into native machine code just before program execution.
 - ‚ÄúJust-in-Time‚Äù means making ‚Äúonly what is needed, when it is needed, and in the amount needed.‚Äù
 - The file generated by JIT needs VM to run

(2) `dartdevc` (**Web**)
- Dart code transpiled into js code

**DEPLOY**

(1) AOT + runtime (**Mobile & Desktop**)
 - The AOT compiler works by compiling your code before it is ‚Äúdelivered‚Äù to whatever runtime environment runs the code. To generate AOT snapshot

	 ```dart2native bin/main.dart -k aot```

 - AOT generates single binary file that can run natively

(2) `dart2js` (**Web**)

# Flutter working

 - Platform exposes OEM (Original Equipment Manufacturer) widgets and service APIs for example camera to build UI and communicate platform services respectively.
 - In cross platform world, OEM widgets and platform specific APIs can't be used directly because they are coming from different environment. For example, a Kotlin's android app is compiled to work with ART (Android Run Time) ecosystem. So, obviously it can't run on iOS which has no ART. 
 - React Native uses OEM widgets but solves the aforementioned problem using bridge (an abstraction layer) so that a developer does not need to be concerned about platform.
 - Flutter uses completely different approach and uses Skia rendering engine to paint the UI so that OEM widgets are not needed anymore.
 - Minimal Flutter app
    - Android: **~4.4 MB**
    - iOS: **~10.9 MB**

# Constructors in Dart
- **Named**
```dart
Fraction.zero() : _numerator = 0, _denominator = 1;
```
- **Redirecting**
```dart
Fraction.oneHalf() : this(1,2);
```
- **Factory** 
	- Returns an object not necessarily a new one
	- Cases where it is very useful:
		- To return an instance of subclass
		- To follow Singleton pattern
		- To return an instance from cache

- **Const**
	- When all class variables are final
	- It can be used as an annotation
	- ```dart
	  class Todo{
		final int title;
		final int description;
		const A(this.title, this.description)
	  }
	  
	  @Todo('Chibi', 'Rename class')
	  class MyClass {
  	    @Todo('Tuwaise', 'Change fielld type')
  	    int value;

  	    @Todo('Anyone', 'Change format')
  	    void printValue() {
    		print('value: $value');
  	    }

  	    @Todo('Anyone', 'Remove this')
  	    MyClass();
	  }
	  
	  void main() {
  		MyClass myClass = new MyClass();
  		InstanceMirror im = reflect(myClass);
  		ClassMirror classMirror = im.type;

  		classMirror.metadata.forEach((metadata) {
    		   if (metadata.reflectee is Todo) {
      		      print(metadata.reflectee.name);
      		      print(metadata.reflectee.description);
    		   }
  		});

  		for (var v in classMirror.declarations.values) {
    		   if (!v.metadata.isEmpty) {
      		      if (v.metadata.first.reflectee is Todo) {
        	         print(v.metadata.first.reflectee.name);
		         print(v.metadata.first.reflectee.description);
      		      }
    	           }
  	        }
	   }
 	  ```
 

