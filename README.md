
# What I learn today
Contains my daily learning that I want to share with youüòÉ

# Flutter code compilation
**Develop**

(1) JIT + VM (**Mobile & Desktop**)
 - JIT compiler converts program source code into native machine code just before program execution.
 - ‚ÄúJust-in-Time‚Äù means making ‚Äúonly what is needed, when it is needed, and in the amount needed.‚Äù
 - The file generated by JIT needs VM to run

(2) `dartdevc` (**Web**)
- Dart code transpiled into js code

**DEPLOY**

(1) AOT + runtime (**Mobile & Desktop**)
 - The AOT compiler works by compiling your code before it is ‚Äúdelivered‚Äù to whatever runtime environment runs the code. To generate AOT snapshot

	 ```dart2native bin/main.dart -k aot```

 - AOT generates single binary file that can run natively

(2) `dart2js` (**Web**)

# Flutter working

 - Platform exposes OEM (Original Equipment Manufacturer) widgets and service APIs for example camera to build UI and communicate platform services respectively.
 - In cross platform world, OEM widgets and platform specific APIs can't be used directly because they are coming from different environment. For example, a Kotlin's android app is compiled to work with ART (Android Run Time) ecosystem. So, obviously it can't run on iOS which has no ART. 
 - React Native uses OEM widgets but solves the aforementioned problem using bridge (an abstraction layer) so that a developer does not need to be concerned about platform.
 - Flutter uses completely different approach and uses Skia rendering engine to paint the UI so that OEM widgets are not needed anymore.
 - Minimal Flutter app
    - Android: **~4.4 MB**
    - iOS: **~10.9 MB**



 

